//
// Generated by Bluespec Compiler (build 38534dc)
//
// On Fri May 21 14:51:21 JST 2021
//
//
// Ports:
// Name                         I/O  size props
// read                           O     1 reg
// RDY_read                       O     1 const
// RDY_load                       O     1
// done                           O     1 reg
// RDY_done                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// load_newdata                   I     8
// EN_load                        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUart(CLK,
	      RST_N,

	      read,
	      RDY_read,

	      load_newdata,
	      EN_load,
	      RDY_load,

	      done,
	      RDY_done);
  input  CLK;
  input  RST_N;

  // value method read
  output read;
  output RDY_read;

  // action method load
  input  [7 : 0] load_newdata;
  input  EN_load;
  output RDY_load;

  // value method done
  output done;
  output RDY_done;

  // signals for module outputs
  wire RDY_done, RDY_load, RDY_read, done, read;

  // inlined wires
  wire fsm_start_wire$whas, fsm_state_set_pw$whas;

  // register data
  reg [7 : 0] data;
  wire [7 : 0] data$D_IN;
  wire data$EN;

  // register doneFlag
  reg doneFlag;
  wire doneFlag$D_IN, doneFlag$EN;

  // register fsm_jj_repeat_count
  reg [7 : 0] fsm_jj_repeat_count;
  wire [7 : 0] fsm_jj_repeat_count$D_IN;
  wire fsm_jj_repeat_count$EN;

  // register fsm_start_reg
  reg fsm_start_reg;
  wire fsm_start_reg$D_IN, fsm_start_reg$EN;

  // register fsm_start_reg_1
  reg fsm_start_reg_1;
  wire fsm_start_reg_1$D_IN, fsm_start_reg_1$EN;

  // register fsm_state_can_overlap
  reg fsm_state_can_overlap;
  wire fsm_state_can_overlap$D_IN, fsm_state_can_overlap$EN;

  // register fsm_state_fired
  reg fsm_state_fired;
  wire fsm_state_fired$D_IN, fsm_state_fired$EN;

  // register fsm_state_mkFSMstate
  reg [3 : 0] fsm_state_mkFSMstate;
  reg [3 : 0] fsm_state_mkFSMstate$D_IN;
  wire fsm_state_mkFSMstate$EN;

  // register odata
  reg odata;
  reg odata$D_IN;
  wire odata$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_fsm_action_l18c13,
       WILL_FIRE_RL_fsm_action_l19c18,
       WILL_FIRE_RL_fsm_action_l23c13,
       WILL_FIRE_RL_fsm_action_ovlp_r_update_l19c7,
       WILL_FIRE_RL_fsm_action_r_init_l19c7,
       WILL_FIRE_RL_fsm_fsm_start,
       WILL_FIRE_RL_fsm_idle_l17c4;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_data$write_1__VAL_2,
	       MUX_fsm_jj_repeat_count$write_1__VAL_1;

  // remaining internal signals
  wire [7 : 0] x__h22748;
  wire NOT_fsm_jj_repeat_count_read__7_BIT_0_8_9_AND__ETC___d52,
       fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d73,
       fsm_jj_repeat_count_read__7_BIT_0_8_AND_NOT_fs_ETC___d47;

  // value method read
  assign read = odata ;
  assign RDY_read = 1'd1 ;

  // action method load
  assign RDY_load =
	     fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d73 &&
	     !fsm_start_reg ;

  // value method done
  assign done = doneFlag ;
  assign RDY_done = 1'd1 ;

  // rule RL_fsm_action_r_init_l19c7
  assign WILL_FIRE_RL_fsm_action_r_init_l19c7 =
	     !fsm_jj_repeat_count[0] && fsm_state_mkFSMstate == 4'd1 ;

  // rule RL_fsm_action_l23c13
  assign WILL_FIRE_RL_fsm_action_l23c13 =
	     fsm_jj_repeat_count[0] && fsm_state_mkFSMstate == 4'd4 ;

  // rule RL_fsm_action_ovlp_r_update_l19c7
  assign WILL_FIRE_RL_fsm_action_ovlp_r_update_l19c7 =
	     fsm_state_can_overlap &&
	     (fsm_jj_repeat_count_read__7_BIT_0_8_AND_NOT_fs_ETC___d47 ||
	      NOT_fsm_jj_repeat_count_read__7_BIT_0_8_9_AND__ETC___d52) ;

  // rule RL_fsm_fsm_start
  assign WILL_FIRE_RL_fsm_fsm_start =
	     fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d73 &&
	     fsm_start_reg ;

  // rule RL_fsm_action_l18c13
  assign WILL_FIRE_RL_fsm_action_l18c13 =
	     fsm_start_wire$whas &&
	     (fsm_state_mkFSMstate == 4'd0 || fsm_state_mkFSMstate == 4'd7) ;

  // rule RL_fsm_action_l19c18
  assign WILL_FIRE_RL_fsm_action_l19c18 =
	     fsm_jj_repeat_count_read__7_BIT_0_8_AND_NOT_fs_ETC___d47 ||
	     fsm_state_mkFSMstate == 4'd3 ||
	     NOT_fsm_jj_repeat_count_read__7_BIT_0_8_9_AND__ETC___d52 ;

  // rule RL_fsm_idle_l17c4
  assign WILL_FIRE_RL_fsm_idle_l17c4 =
	     !fsm_start_wire$whas && fsm_state_mkFSMstate == 4'd7 ;

  // inputs to muxes for submodule ports
  assign MUX_data$write_1__VAL_2 = { 1'd0, data[7:1] } ;
  assign MUX_fsm_jj_repeat_count$write_1__VAL_1 =
	     fsm_jj_repeat_count[7] ? 8'd1 : x__h22748 ;

  // inlined wires
  assign fsm_start_wire$whas =
	     WILL_FIRE_RL_fsm_fsm_start ||
	     fsm_start_reg_1 && !fsm_state_fired ;
  assign fsm_state_set_pw$whas =
	     WILL_FIRE_RL_fsm_idle_l17c4 || fsm_state_mkFSMstate == 4'd6 ||
	     WILL_FIRE_RL_fsm_action_l23c13 ||
	     WILL_FIRE_RL_fsm_action_l19c18 ||
	     WILL_FIRE_RL_fsm_action_r_init_l19c7 ||
	     WILL_FIRE_RL_fsm_action_l18c13 ;

  // register data
  assign data$D_IN = EN_load ? load_newdata : MUX_data$write_1__VAL_2 ;
  assign data$EN = EN_load || WILL_FIRE_RL_fsm_action_l19c18 ;

  // register doneFlag
  assign doneFlag$D_IN = !EN_load ;
  assign doneFlag$EN = EN_load || fsm_state_mkFSMstate == 4'd6 ;

  // register fsm_jj_repeat_count
  assign fsm_jj_repeat_count$D_IN =
	     WILL_FIRE_RL_fsm_action_ovlp_r_update_l19c7 ?
	       MUX_fsm_jj_repeat_count$write_1__VAL_1 :
	       8'd1 ;
  assign fsm_jj_repeat_count$EN =
	     WILL_FIRE_RL_fsm_action_ovlp_r_update_l19c7 ||
	     WILL_FIRE_RL_fsm_action_r_init_l19c7 ;

  // register fsm_start_reg
  assign fsm_start_reg$D_IN = !WILL_FIRE_RL_fsm_fsm_start ;
  assign fsm_start_reg$EN = WILL_FIRE_RL_fsm_fsm_start || EN_load ;

  // register fsm_start_reg_1
  assign fsm_start_reg_1$D_IN = fsm_start_wire$whas ;
  assign fsm_start_reg_1$EN = 1'd1 ;

  // register fsm_state_can_overlap
  assign fsm_state_can_overlap$D_IN =
	     fsm_state_set_pw$whas ||
	     !WILL_FIRE_RL_fsm_action_ovlp_r_update_l19c7 &&
	     fsm_state_can_overlap ;
  assign fsm_state_can_overlap$EN = 1'd1 ;

  // register fsm_state_fired
  assign fsm_state_fired$D_IN = fsm_state_set_pw$whas ;
  assign fsm_state_fired$EN = 1'd1 ;

  // register fsm_state_mkFSMstate
  always@(WILL_FIRE_RL_fsm_idle_l17c4 or
	  WILL_FIRE_RL_fsm_action_l18c13 or
	  WILL_FIRE_RL_fsm_action_r_init_l19c7 or
	  WILL_FIRE_RL_fsm_action_l19c18 or
	  WILL_FIRE_RL_fsm_action_l23c13 or fsm_state_mkFSMstate)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_fsm_idle_l17c4: fsm_state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_fsm_action_l18c13: fsm_state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_fsm_action_r_init_l19c7: fsm_state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_fsm_action_l19c18: fsm_state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_fsm_action_l23c13: fsm_state_mkFSMstate$D_IN = 4'd6;
      fsm_state_mkFSMstate == 4'd6: fsm_state_mkFSMstate$D_IN = 4'd7;
      default: fsm_state_mkFSMstate$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign fsm_state_mkFSMstate$EN =
	     WILL_FIRE_RL_fsm_idle_l17c4 || WILL_FIRE_RL_fsm_action_l18c13 ||
	     WILL_FIRE_RL_fsm_action_r_init_l19c7 ||
	     WILL_FIRE_RL_fsm_action_l19c18 ||
	     WILL_FIRE_RL_fsm_action_l23c13 ||
	     fsm_state_mkFSMstate == 4'd6 ;

  // register odata
  always@(WILL_FIRE_RL_fsm_action_l19c18 or
	  data or
	  WILL_FIRE_RL_fsm_action_l18c13 or WILL_FIRE_RL_fsm_action_l23c13)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_fsm_action_l19c18: odata$D_IN = data[0];
      WILL_FIRE_RL_fsm_action_l18c13: odata$D_IN = 1'h0;
      WILL_FIRE_RL_fsm_action_l23c13: odata$D_IN = 1'h1;
      default: odata$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign odata$EN =
	     WILL_FIRE_RL_fsm_action_l19c18 ||
	     WILL_FIRE_RL_fsm_action_l18c13 ||
	     WILL_FIRE_RL_fsm_action_l23c13 ;

  // remaining internal signals
  assign NOT_fsm_jj_repeat_count_read__7_BIT_0_8_9_AND__ETC___d52 =
	     !fsm_jj_repeat_count[0] && fsm_state_mkFSMstate == 4'd4 ;
  assign fsm_abort_whas_AND_fsm_abort_wget_OR_fsm_state_ETC___d73 =
	     (fsm_state_mkFSMstate == 4'd0 || fsm_state_mkFSMstate == 4'd7) &&
	     (!fsm_start_reg_1 || fsm_state_fired) ;
  assign fsm_jj_repeat_count_read__7_BIT_0_8_AND_NOT_fs_ETC___d47 =
	     fsm_jj_repeat_count[0] && fsm_state_mkFSMstate == 4'd1 ||
	     fsm_state_mkFSMstate == 4'd2 ;
  assign x__h22748 = { fsm_jj_repeat_count[6:0], 1'd0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        doneFlag <= `BSV_ASSIGNMENT_DELAY 1'd1;
	fsm_jj_repeat_count <= `BSV_ASSIGNMENT_DELAY 8'd1;
	fsm_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	fsm_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	odata <= `BSV_ASSIGNMENT_DELAY 1'h1;
      end
    else
      begin
        if (doneFlag$EN) doneFlag <= `BSV_ASSIGNMENT_DELAY doneFlag$D_IN;
	if (fsm_jj_repeat_count$EN)
	  fsm_jj_repeat_count <= `BSV_ASSIGNMENT_DELAY
	      fsm_jj_repeat_count$D_IN;
	if (fsm_start_reg$EN)
	  fsm_start_reg <= `BSV_ASSIGNMENT_DELAY fsm_start_reg$D_IN;
	if (fsm_start_reg_1$EN)
	  fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY fsm_start_reg_1$D_IN;
	if (fsm_state_can_overlap$EN)
	  fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      fsm_state_can_overlap$D_IN;
	if (fsm_state_fired$EN)
	  fsm_state_fired <= `BSV_ASSIGNMENT_DELAY fsm_state_fired$D_IN;
	if (fsm_state_mkFSMstate$EN)
	  fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      fsm_state_mkFSMstate$D_IN;
	if (odata$EN) odata <= `BSV_ASSIGNMENT_DELAY odata$D_IN;
      end
    if (data$EN) data <= `BSV_ASSIGNMENT_DELAY data$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    data = 8'hAA;
    doneFlag = 1'h0;
    fsm_jj_repeat_count = 8'hAA;
    fsm_start_reg = 1'h0;
    fsm_start_reg_1 = 1'h0;
    fsm_state_can_overlap = 1'h0;
    fsm_state_fired = 1'h0;
    fsm_state_mkFSMstate = 4'hA;
    odata = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_fsm_action_l23c13 && fsm_state_mkFSMstate == 4'd6)
	$display("Error: \"mkUart.bsv\", line 23, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fsm_action_l23c13] and\n  [RL_fsm_action_l25c16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_fsm_action_l18c13 &&
	  (WILL_FIRE_RL_fsm_action_r_init_l19c7 ||
	   WILL_FIRE_RL_fsm_action_l19c18 ||
	   WILL_FIRE_RL_fsm_action_l23c13 ||
	   fsm_state_mkFSMstate == 4'd6))
	$display("Error: \"mkUart.bsv\", line 18, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fsm_action_l18c13] and\n  [RL_fsm_action_r_init_l19c7, RL_fsm_action_l19c18, RL_fsm_action_l23c13,\n  RL_fsm_action_l25c16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_fsm_action_r_init_l19c7 &&
	  (WILL_FIRE_RL_fsm_action_l19c18 || WILL_FIRE_RL_fsm_action_l23c13 ||
	   fsm_state_mkFSMstate == 4'd6))
	$display("Error: \"mkUart.bsv\", line 19, column 7: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fsm_action_r_init_l19c7] and\n  [RL_fsm_action_l19c18, RL_fsm_action_l23c13, RL_fsm_action_l25c16] ) fired\n  in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_fsm_action_l19c18 &&
	  (WILL_FIRE_RL_fsm_action_l23c13 || fsm_state_mkFSMstate == 4'd6))
	$display("Error: \"mkUart.bsv\", line 19, column 18: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fsm_action_l19c18] and\n  [RL_fsm_action_l23c13, RL_fsm_action_l25c16] ) fired in the same clock\n  cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkUart

